% ПІБ: Yermolovych Zakhar Maksymovych

% ------------------------------------------------------------
% 1. Ділення з остачею (без div/mod, використовувати віднімання)
% ------------------------------------------------------------

% div_mod(++A, ++B, ?Div, ?Mod)
% Призначення (мультипризначенність):
% 1) div_mod(++A, ++B, -Div, -Mod)  : обчислити Div та Mod для A >= 0, B > 0.
% 2) div_mod(++A, ++B, +Div, +Mod)  : перевірити правильність заданих Div та Mod.
% Інших змістовних призначень нема, бо A і B використовуються в арифметичних порівняннях.
div_mod(A, B, Div, Mod) :-
        A >= 0,
        B > 0,
        div_mod_acc(A, B, 0, Div, Mod).

/** <examples>
?- div_mod(17, 5, D, M).
% D = 3,
% M = 2.

?- div_mod(20, 4, D, M).
% D = 5,
% M = 0.

?- div_mod(20, 4, 5, 0).
% true.

?- div_mod(20, 4, 4, 0).
% false.
*/


% div_mod_acc(++A, ++B, ++Acc, ?Div, ?Mod)
% Acc — лічильник частки (скільки разів відняли B від A).
% Призначення (мультипризначенність):
% 1) div_mod_acc(++A, ++B, ++Acc, -Div, -Mod) : обчислити Div та Mod (службовий предикат).
% 2) div_mod_acc(++A, ++B, ++Acc, +Div, +Mod) : перевірити правильність заданих Div та Mod.
% Інших змістовних призначень нема, бо A,B,Acc використовуються в арифметичних порівняннях та обчисленнях.
div_mod_acc(A, B, Acc, Div, Mod) :-
        A < B,
        Div = Acc,
        Mod = A.
div_mod_acc(A, B, Acc, Div, Mod) :-
        A >= B,
        A1   is A - B,
        Acc1 is Acc - (-1),   % +1 лише через віднімання
        div_mod_acc(A1, B, Acc1, Div, Mod).

/** <examples>
?- div_mod_acc(7, 5, 0, D, M).
% D = 1,
% M = 2.

?- div_mod_acc(7, 5, 0, 1, 2).
% true.
*/


% ------------------------------------------------------------
% 2. Піднесення до степеню (без вбудованих функцій)
%    2.1 лінійне, 2.2 логарифмічне
% ------------------------------------------------------------

% stepin_lin(++A, ++N, ?R)
% Призначення (мультипризначенність):
% 1) stepin_lin(++A, ++N, -R) : обчислити A^N для N >= 0.
% 2) stepin_lin(++A, ++N, +R) : перевірити, що R = A^N.
% Інших змістовних призначень нема, бо A,N входять в арифметику.
stepin_lin(A, N, R) :-
        N >= 0,
        stepin_lin_acc(A, N, 1, R).

/** <examples>
?- stepin_lin(2, 10, R).
% R = 1024.

?- stepin_lin(5, 0, R).
% R = 1.

?- stepin_lin(2, 10, 1024).
% true.
*/


% stepin_lin_acc(++A, ++N, ++Acc, ?R)
% Acc — поточний накопичений добуток.
% Призначення (мультипризначенність):
% 1) stepin_lin_acc(++A, ++N, ++Acc, -R) : обчислити R (службовий предикат).
% 2) stepin_lin_acc(++A, ++N, ++Acc, +R) : перевірити правильність R.
% Інших змістовних призначень нема, бо A,N,Acc використовуються в арифметиці та порівняннях.
stepin_lin_acc(_, 0, Acc, R) :-
        R = Acc.
stepin_lin_acc(A, N, Acc, R) :-
        N > 0,
        Acc1 is Acc * A,
        N1   is N - 1,
        stepin_lin_acc(A, N1, Acc1, R).

/** <examples>
?- stepin_lin_acc(2, 3, 1, R).
% R = 8.

?- stepin_lin_acc(2, 3, 1, 8).
% true.
*/


% stepin_log(++A, ++N, ?R)
% Призначення (мультипризначенність):
% 1) stepin_log(++A, ++N, -R) : обчислити A^N за O(log N), N >= 0.
% 2) stepin_log(++A, ++N, +R) : перевірити, що R = A^N.
% Примітка: парність (Rem) та N//2 отримуються через div_mod/4 (без використання mod).
stepin_log(A, N, R) :-
        N >= 0,
        stepin_log_rec(A, N, R).

/** <examples>
?- stepin_log(2, 10, R).
% R = 1024.

?- stepin_log(3, 5, R).
% R = 243.

?- stepin_log(3, 5, 243).
% true.
*/


% stepin_log_rec(++A, ++N, ?R)
% Призначення (мультипризначенність):
% 1) stepin_log_rec(++A, ++N, -R) : обчислити R (службовий предикат).
% 2) stepin_log_rec(++A, ++N, +R) : перевірити правильність R.
% Інших змістовних призначень нема, бо A,N входять в арифметичні порівняння/обчислення.
stepin_log_rec(_, 0, R) :-
        R = 1.
stepin_log_rec(A, 1, R) :-
        R = A.
stepin_log_rec(A, N, R) :-
        N > 1,
        div_mod(N, 2, Q, Rem),       % Rem = 0 (парне) або 1 (непарне)
        stepin_log_rec(A, Q, R1),
        Sq is R1 * R1,
        stepin_log_finish(Rem, Sq, A, R).

/** <examples>
?- stepin_log_rec(3, 5, R).
% R = 243.

?- stepin_log_rec(3, 5, 243).
% true.
*/


% stepin_log_finish(++Rem, ++Sq, ++A, ?R)
% Rem — остача від ділення N на 2 (0 або 1).
% Призначення (мультипризначенність):
% 1) stepin_log_finish(++Rem, ++Sq, ++A, -R) : обчислити R (службовий предикат).
% 2) stepin_log_finish(++Rem, ++Sq, ++A, +R) : перевірити правильність R.
% Інших змістовних призначень нема, бо Rem використовується у виборі правила, Sq,A у арифметиці.
stepin_log_finish(0, Sq, _, R) :-
        R is Sq.
stepin_log_finish(1, Sq, A, R) :-
        R is Sq * A.

/** <examples>
?- stepin_log_finish(1, 9, 2, R).
% R = 18.

?- stepin_log_finish(0, 16, 100, 16).
% true.
*/


% ------------------------------------------------------------
% 3. Числа Фібоначчі
%    3.1 ітеративно, 3.2 рекурсією
% ------------------------------------------------------------

% fib_iter(++N, ?F)
% Призначення (мультипризначенність):
% 1) fib_iter(++N, -F) : обчислити F_N для N >= 0 (ітеративно, хвостова рекурсія).
% 2) fib_iter(++N, +F) : перевірити, що F відповідає F_N.
% Інших змістовних призначень нема, бо N входить в арифметичні порівняння/обчислення.
fib_iter(N, F) :-
        N >= 0,
        fib_iter_acc(0, 1, N, F).

/** <examples>
?- fib_iter(0, F).
% F = 0.

?- fib_iter(10, F).
% F = 55.

?- fib_iter(10, 55).
% true.
*/


% fib_iter_acc(++A, ++B, ++N, ?F)
% Тут A=F_k, B=F_(k+1), N — скільки кроків лишилось.
% Призначення (мультипризначенність):
% 1) fib_iter_acc(++A, ++B, ++N, -F) : обчислити F (службовий предикат).
% 2) fib_iter_acc(++A, ++B, ++N, +F) : перевірити правильність F.
% Інших змістовних призначень нема, бо A,B,N входять в арифметику та порівняння.
fib_iter_acc(A, _, 0, F) :-
        F = A.
fib_iter_acc(A, B, N, F) :-
        N > 0,
        N1 is N - 1,
        S  is A + B,
        fib_iter_acc(B, S, N1, F).

/** <examples>
?- fib_iter_acc(0, 1, 10, F).
% F = 55.

?- fib_iter_acc(0, 1, 10, 55).
% true.
*/


% fib_rec(++N, ?F)
% Призначення (мультипризначенність):
% 1) fib_rec(++N, -F) : обчислити F_N для N >= 0 (рекурсія, експоненційно).
% 2) fib_rec(++N, +F) : перевірити, що F відповідає F_N.
% Інших змістовних призначень нема, бо N входить в арифметичні порівняння/обчислення.
fib_rec(0, F) :-
        F = 0.
fib_rec(1, F) :-
        F = 1.
fib_rec(N, F) :-
        N > 1,
        N1 is N - 1,
        N2 is N - 2,
        fib_rec(N1, F1),
        fib_rec(N2, F2),
        F  is F1 + F2.

/** <examples>
?- fib_rec(10, F).
% F = 55.

?- fib_rec(10, 55).
% true.
*/


% ------------------------------------------------------------
% 4. Розклад числа на прості множники (виведення всіх множників)
% ------------------------------------------------------------

% prosti(++N, -P)
% Призначення (мультипризначенність):
% 1) prosti(++N, -P) : по черзі (бек-трекінгом) вивести всі прості множники N (з кратністю).
% 2) prosti(++N, +P) : перевірити, що P з’являється серед простих множників N.
% Інших змістовних призначень нема, бо N використовується в арифметиці.
prosti(N, P) :-
        N > 1,
        first_factor(N, F, N1),
        (   P = F
        ;   N1 > 1,
            prosti(N1, P)
        ).

/** <examples>
?- prosti(360, P).
% P = 2 ;
% P = 2 ;
% P = 2 ;
% P = 3 ;
% P = 3 ;
% P = 5.

?- prosti(13, P).
% P = 13.
*/


% first_factor(++N, ?F, ?N1)
% F — найменший простий дільник N, N1 = N / F.
% Призначення (мультипризначенність):
% 1) first_factor(++N, -F, -N1) : обчислити F та N1.
% 2) first_factor(++N, +F, +N1) : перевірити правильність F та N1.
% Інших змістовних призначень нема, бо N входить в арифметичні порівняння/обчислення.
first_factor(N, F, N1) :-
        N > 1,
        first_factor_from(N, 2, F),
        div_mod(N, F, N1, 0).

/** <examples>
?- first_factor(360, F, N1).
% F = 2,
% N1 = 180.

?- first_factor(13, 13, 1).
% true.
*/


% first_factor_from(++N, ++D, ?F)
% Підбір дільника D від 2 вгору; якщо D*D > N — N просте.
% Призначення (мультипризначенність):
% 1) first_factor_from(++N, ++D, -F) : знайти найменший дільник F, починаючи з D.
% 2) first_factor_from(++N, ++D, +F) : перевірити правильність F.
% Інших змістовних призначень нема, бо N,D використовуються в арифметичних порівняннях/обчисленнях.
first_factor_from(N, D, F) :-
        D * D =< N,
        div_mod(N, D, _, R),
        first_factor_choose(R, N, D, F).
first_factor_from(N, D, F) :-
        D * D > N,
        F = N.

/** <examples>
?- first_factor_from(360, 2, F).
% F = 2.

?- first_factor_from(13, 2, F).
% F = 13.
*/


% first_factor_choose(++R, ++N, ++D, ?F)
% Якщо R=0, то D ділить N і F=D; інакше збільшуємо D.
% Призначення (мультипризначенність):
% 1) first_factor_choose(++R, ++N, ++D, -F) : обчислити F (службовий предикат).
% 2) first_factor_choose(++R, ++N, ++D, +F) : перевірити правильність F.
% Інших змістовних призначень нема, бо R,N,D входять в арифметику та порівняння.
first_factor_choose(0, _, D, F) :-
        F = D.
first_factor_choose(R, N, D, F) :-
        R =\= 0,          % \=\, не 0 (арифметичне порівняння)
        D1 is D + 1,
        first_factor_from(N, D1, F).

/** <examples>
?- first_factor_choose(0, 360, 2, F).
% F = 2.

?- first_factor_choose(1, 360, 2, F).
% F = 3.
*/


% ------------------------------------------------------------
% 5. Алгоритм Евкліда пошуку НСД
% ------------------------------------------------------------

% evklid(++A, ++B, ?G)
% Призначення (мультипризначенність):
% 1) evklid(++A, ++B, -G) : обчислити НСД(A,B) для A>=0, B>=0.
% 2) evklid(++A, ++B, +G) : перевірити правильність заданого G.
% Інших змістовних призначень нема, бо A,B входять в арифметичні порівняння/обчислення.
evklid(A, B, G) :-
        A >= 0,
        B >= 0,
        evklid_rec(A, B, G).

/** <examples>
?- evklid(48, 18, G).
% G = 6.

?- evklid(270, 192, G).
% G = 6.

?- evklid(48, 18, 6).
% true.
*/


% evklid_rec(++A, ++B, ?G)
% Службова рекурсія: GCD(A,B) = GCD(B, A mod B).
% Примітка: остача береться через div_mod/4.
% Призначення (мультипризначенність):
% 1) evklid_rec(++A, ++B, -G) : обчислити G (службовий предикат).
% 2) evklid_rec(++A, ++B, +G) : перевірити правильність G.
% Інших змістовних призначень нема, бо A,B входять в арифметику/порівняння.
evklid_rec(A, 0, G) :-
        G = A.
evklid_rec(A, B, G) :-
        B > 0,
        div_mod(A, B, _, R),
        evklid_rec(B, R, G).

/** <examples>
?- evklid_rec(48, 18, G).
% G = 6.

?- evklid_rec(48, 18, 6).
% true.
*/


% ------------------------------------------------------------
% 6. Сума 1/1! + 1/2! + ... + 1/N! (рекурентні співвідношення)
% ------------------------------------------------------------

% ryad(++N, -S)
% Призначення (мультипризначенність):
% 1) ryad(++N, -S) : обчислити суму для N >= 0.
% Інших змістовних призначень нема, бо N входить в арифметичні порівняння.
% Примітка: використано rdiv (SWI-Prolog) для точних раціональних чисел.
ryad(N, S) :-
        N >= 0,
        ryad_start(N, S).

/** <examples>
?- ryad(0, S).
% S = 0.

?- ryad(5, S).
% S = 103r60.

?- ryad(6, S).
% S = 1237r720.
*/


% ryad_start(++N, -S)
% Ініціалізація рекурентного підрахунку.
% Призначення (мультипризначенність):
% 1) ryad_start(++N, -S) : обчислити S (службовий предикат).
% Інших змістовних призначень нема, бо N входить в арифметичні порівняння.
ryad_start(0, S) :-
        S = 0.
ryad_start(N, S) :-
        N > 0,
        T1 is 1 rdiv 1,     % T1 = 1/1!
        S1 is 1 rdiv 1,     % S1 = T1
        ryad_acc(1, N, T1, S1, S).

/** <examples>
?- ryad_start(6, S).
% S = 1237r720.
*/


% ryad_acc(++I, ++N, ++Ti, ++Si, -S)
% Рекурентно:
% T_k = T_{k-1} / k
% S_k = S_{k-1} + T_k
% Призначення (мультипризначенність):
% 1) ryad_acc(++I, ++N, ++Ti, ++Si, -S) : обчислити S (службовий предикат).
% Інших змістовних призначень нема, бо I,N входять в арифметичні порівняння/обчислення.
ryad_acc(I, N, _, Si, S) :-
        I =:= N,            % =:= арифметична рівність
        S = Si.
ryad_acc(I, N, Ti, Si, S) :-
        I < N,
        I1  is I + 1,
        Ti1 is Ti rdiv I1,
        Si1 is Si + Ti1,
        ryad_acc(I1, N, Ti1, Si1, S).

/** <examples>
?- ryad_acc(1, 5, 1 rdiv 1, 1 rdiv 1, S).
% S = 103r60.
*/
