% Yermolovych Zakhar Maksymovych

:- use_module(library(lists)).

% ============================================================
% 1) У тризначному числі, всі цифри якого непарні, закреслили
%    середню цифру. Отримане двозначне число є дільником
%    вихідного. Знайти всі такі тризначні числа.
% ============================================================

% z1_solution(?N, ?D)
% Індикатори:
%   ?N  - універсальний (трицифрове число)
%   ?D  - універсальний (двозначне число після "закреслення" середньої цифри)
%
% Призначення (змістовні режими):
%   1) z1_solution(--, --) : породити всі пари (N,D).
%   2) z1_solution(+,  --) : для заданого N знайти D (або перевірити існування).
%   3) z1_solution(+,   +) : перевірка пари (N,D).
%
% (Режими, де D заданий, а N вільний, теж працюють: підбір N за D.)
z1_solution(N, D) :-
    z1_three_digit_odd(N),
    z1_remove_middle_digit(N, D),
    D >= 10, D =< 99,
    0 is N mod D.

% z1_solutions(--Ns)
% Індикатори:
%   --Ns - обов’язково вільна змінна (вихідний список розв’язків)
%
% Призначення:
%   1) z1_solutions(--): отримати список всіх N.
%
% Неочевидні built-in:
%   - findall/3: збирає всі розв’язки в список.
z1_solutions(Ns) :-
    findall(N, z1_solution(N, _D), Ns).

% z1_three_digit_odd(?N)
% Індикатори:
%   ?N - універсальний
%
% Призначення:
%   1) z1_three_digit_odd(--): породити всі 3-цифрові числа з непарними цифрами.
%   2) z1_three_digit_odd(+) : перевірити, що N має 3 цифри і всі непарні.
%
% Неочевидні built-in:
%   - between/3: генерує/перевіряє цілі значення в діапазоні.
%   - var/1: істина, якщо аргумент є вільною змінною.
z1_three_digit_odd(N) :-
    (   var(N)
    ->  between(100, 999, N)
    ;   N >= 100, N =< 999
    ),
    A is N // 100,
    B is (N // 10) mod 10,
    C is N mod 10,
    1 is A mod 2,
    1 is B mod 2,
    1 is C mod 2.

% z1_remove_middle_digit(++N, --D)
% Індикатори:
%   ++N - обов’язково конкретизований
%   --D - обов’язково вільна змінна
%
% Призначення:
%   1) z1_remove_middle_digit(++, --): отримати двозначне число D = 10*A + C.
%
% Пояснення відсутності інших змістовних призначень:
%   Використовується арифметика (is/2), тому N має бути конкретизований.
z1_remove_middle_digit(N, D) :-
    A is N // 100,
    C is N mod 10,
    D is 10*A + C.

/** <examples>
?- z1_solutions(Ns).
% Ns = [135, 195, 315].

?- z1_solution(195, D).
% D = 15.

?- z1_solution(N, 15).
% N = 135 ;
% N = 195 ;
% false.
*/


% ============================================================
% 2) Знайти чотиризначне число, яке є точним квадратом, у якого
%    дві перші цифри однакові та дві останні також однакові.
% ============================================================

% z2_square(?N)
% Індикатори:
%   ?N - універсальний (4-цифровий квадрат виду A A B B)
%
% Призначення:
%   1) z2_square(--): породити всі такі N.
%   2) z2_square(+) : перевірити, що N має потрібну властивість.
%
% Неочевидні built-in:
%   - sqrt/1: квадратний корінь (дійсний).
%   - floor/1: найбільше ціле ≤ X (беремо цілу частину кореня для перевірки квадрату).
z2_square(N) :-
    (   var(N)
    ->  between(32, 99, R),                 % бо 32^2=1024, 99^2=9801
        N is R*R
    ;   N >= 1000, N =< 9999,
        R is floor(sqrt(N)),
        N =:= R*R
    ),
    A1 is N // 1000,
    A2 is (N // 100) mod 10,
    B1 is (N // 10) mod 10,
    B2 is N mod 10,
    A1 =:= A2,
    B1 =:= B2.

/** <examples>
?- z2_square(N).
% N = 7744 ;
% false.
*/


% ============================================================
% 3) Скільки існує цілих чисел від 1 до 2025, які не діляться
%    на жодне з чисел 6, 10, 15?
% ============================================================

% z3_count_not_divisible(++Max, --Count)
% Індикатори:
%   ++Max   - обов’язково конкретизований (верхня межа)
%   --Count - обов’язково вільна змінна (відповідь)
%
% Призначення:
%   1) z3_count_not_divisible(++, --): порахувати за включенням-виключенням.
%
% Пояснення відсутності інших змістовних призначень:
%   Використовується арифметика (//, is), тому Max має бути конкретизований.
z3_count_not_divisible(Max, Count) :-
    C6  is Max // 6,
    C10 is Max // 10,
    C15 is Max // 15,
    L610 is 30,                              % lcm(6,10)=30
    L615 is 30,                              % lcm(6,15)=30
    L1015 is 30,                             % lcm(10,15)=30
    LAll is 30,                              % lcm(6,10,15)=30
    C610  is Max // L610,
    C615  is Max // L615,
    C1015 is Max // L1015,
    CAll  is Max // LAll,
    DivAny is C6 + C10 + C15
             - C610 - C615 - C1015
             + CAll,
    Count is Max - DivAny.

% z3_answer(--Count)
% Індикатори:
%   --Count - обов’язково вільна змінна
%
% Призначення:
%   1) z3_answer(--): відповідь для Max=2025.
z3_answer(Count) :-
    z3_count_not_divisible(2025, Count).

/** <examples>
?- z3_answer(C).
% C = 1485.
*/


% ============================================================
% 4) Знайти найменше натуральне число M, яке має властивість:
%    сума квадратів 11 послідовних натуральних чисел, починаючи
%    з M, є точним квадратом.
% ============================================================

% z4_sum11_squares(++M, --Sum)
% Індикатори:
%   ++M   - обов’язково конкретизований
%   --Sum - обов’язково вільна змінна
%
% Призначення:
%   1) z4_sum11_squares(++, --): обчислити суму квадратів (M..M+10).
%
% Пояснення відсутності інших змістовних призначень:
%   Використовується акумуляторна рекурсія з арифметикою, тому M має бути конкретизований.
z4_sum11_squares(M, Sum) :-
    z4_sum11_squares_(M, 0, 0, Sum).

% z4_sum11_squares_(++M, ++K, ++Acc, --Sum)
% Індикатори:
%   ++M   - обов’язково конкретизований (початкове число)
%   ++K   - обов’язково конкретизований (лічильник доданків, 0..11)
%   ++Acc - обов’язково конкретизований (поточна сума-акумулятор)
%   --Sum - обов’язково вільна змінна (результат)
%
% Призначення:
%   1) z4_sum11_squares_(++, ++, ++, --): детерміновано обчислити Sum.
%
% Пояснення відсутності інших змістовних призначень:
%   Через використання is/2 та порівнянь усі вхідні параметри мають бути конкретизовані.
z4_sum11_squares_(M, K, Acc, Sum) :-
    (   K =:= 11
    ->  Sum = Acc
    ;   X is M + K,
        Acc1 is Acc + X*X,
        K1 is K + 1,
        z4_sum11_squares_(M, K1, Acc1, Sum)
    ).

% z4_is_square(++X)
% Індикатори:
%   ++X - обов’язково конкретизований
%
% Призначення:
%   1) z4_is_square(++) : перевірка, що X — точний квадрат.
%
% Неочевидні built-in:
%   - sqrt/1 + floor/1: для перевірки квадрата через цілу частину кореня.
z4_is_square(X) :-
    X >= 0,
    R is floor(sqrt(X)),
    X =:= R*R.

% z4_min_m(--M)
% Індикатори:
%   --M - обов’язково вільна змінна
%
% Призначення:
%   1) z4_min_m(--): знайти мінімальне M (пошуком від 1 вгору).
z4_min_m(M) :-
    z4_min_m_from(1, M).

% z4_min_m_from(++Cur, --M)
% Індикатори:
%   ++Cur - обов’язково конкретизований (поточний кандидат M)
%   --M   - обов’язково вільна змінна (відповідь)
%
% Призначення:
%   1) z4_min_m_from(++, --): знайти мінімальне M, перебираючи Cur, Cur+1, ...
%
% Пояснення відсутності інших змістовних призначень:
%   Cur має бути конкретизований, бо обчислюємо суму квадратів і збільшуємо Cur арифметично.
z4_min_m_from(Cur, M) :-
    z4_sum11_squares(Cur, Sum),
    (   z4_is_square(Sum)
    ->  M = Cur
    ;   Cur1 is Cur + 1,
        z4_min_m_from(Cur1, M)
    ).

/** <examples>
?- z4_min_m(M), z4_sum11_squares(M, S).
% M = 18,
% S = 5929.

?- z4_is_square(5929).
% true.
*/


% ============================================================
% 5) У послідовності 1998737... кожна цифра, починаючи з п’ятої,
%    дорівнює останній цифрі суми чотирьох попередніх цифр.
%    Через скільки цифр знову зустрінеться початкова комбінація 1998
%    (тобто скільки цифр у періоді)?
% ============================================================

% z5_period(--P)
% Індикатори:
%   --P - обов’язково вільна змінна (довжина періоду)
%
% Призначення:
%   1) z5_period(--): обчислити період для старту [1,9,9,8].
z5_period(P) :-
    Init = [1,9,9,8],
    z5_period_from_state(Init, Init, 0, P).

% z5_period_from_state(++Init, ++State, ++T, --P)
% Індикатори:
%   ++Init  - обов’язково конкретизований (початковий стан, 4 цифри)
%   ++State - обов’язково конкретизований (поточний стан, останні 4 цифри)
%   ++T     - обов’язково конкретизований (скільки кроків після старту)
%   --P     - обов’язково вільна змінна (період)
%
% Призначення:
%   1) z5_period_from_state(++, ++, ++, --): детерміновано знайти період, ітеруючи стани.
%
% Пояснення відсутності інших змістовних призначень:
%   Через арифметику (T1 is T+1) Init/State/T мають бути конкретизовані.
z5_period_from_state(Init, State, T, P) :-
    (   T > 0,
        State = Init
    ->  P = T
    ;   z5_next_state(State, NextState),
        T1 is T + 1,
        z5_period_from_state(Init, NextState, T1, P)
    ).

% z5_next_state(++State, --NextState)
% Індикатори:
%   ++State     - обов’язково конкретизований (список з 4 цифр)
%   --NextState - обов’язково вільна змінна (нові останні 4 цифри)
%
% Призначення:
%   1) z5_next_state(++, --): побудувати наступний стан.
%
% Пояснення відсутності інших змістовних призначень:
%   Використовується is/2, тому State має бути конкретизований.
z5_next_state([A,B,C,D], [B,C,D,N]) :-
    S is A + B + C + D,
    N is S mod 10.

/** <examples>
?- z5_period(P).
% P = 1560.
*/


% ============================================================
% 6) Підрахування кількості щасливих квитків з 6 цифрами,
%    якщо їх надруковано в п’ятірковій системі числення.
%    № першого квитка "000001" (тобто "000000" не друкувався).
%    "Щасливий" = сума перших 3 цифр дорівнює сумі останніх 3.
% ============================================================

% z6_lucky_count(--Count)
% Індикатори:
%   --Count - обов’язково вільна змінна
%
% Призначення:
%   1) z6_lucky_count(--): порахувати кількість щасливих квитків (без "000000").
z6_lucky_count(Count) :-
    z6_counts_for_three_digits(Counts),
    z6_sum_of_squares(Counts, TotalWith000000),
    Count is TotalWith000000 - 1.            % "000000" щасливий, але не друкувався

% z6_counts_for_three_digits(--Counts)
% Індикатори:
%   --Counts - обов’язково вільна змінна (Sum-Qty для суми 3 цифр у base-5)
%
% Призначення:
%   1) z6_counts_for_three_digits(--): зібрати розподіл кількостей за сумою.
%
% Неочевидні built-in:
%   - msort/2: сортує список, зберігаючи повтори.
z6_counts_for_three_digits(Counts) :-
    findall(Sum,
            ( between(0,4,A),
              between(0,4,B),
              between(0,4,C),
              Sum is A+B+C
            ),
            Sums),
    msort(Sums, Sorted),
    z6_pack_counts(Sorted, Counts).

% z6_pack_counts(++Sorted, --Counts)
% Індикатори:
%   ++Sorted - обов’язково конкретизований (відсортований список сум)
%   --Counts - обов’язково вільна змінна (список Sum-Qty)
%
% Призначення:
%   1) z6_pack_counts(++, --): упакувати однакові значення у формат Sum-Qty.
%
% Пояснення відсутності інших змістовних призначень:
%   Sorted має бути конкретизований, бо рекурсія розбирає структуру списку.
z6_pack_counts([], []).
z6_pack_counts([H|T], [H-N|Rest]) :-
    z6_take_same(H, T, 1, N, Tail),
    z6_pack_counts(Tail, Rest).

% z6_take_same(++Val, ++List, ++Acc, --N, --Tail)
% Індикатори:
%   ++Val  - обов’язково конкретизований (значення, яке рахуємо)
%   ++List - обов’язково конкретизований (решта списку)
%   ++Acc  - обов’язково конкретизований (накопичувач кількості)
%   --N    - обов’язково вільна змінна (підсумкова кількість)
%   --Tail - обов’язково вільна змінна (залишок списку з іншими значеннями)
%
% Призначення:
%   1) z6_take_same(++, ++, ++, --, --): підрахувати скільки разів Val іде на початку List.
%
% Пояснення відсутності інших змістовних призначень:
%   Використовується =:= та is/2, тому Val/List/Acc мають бути конкретизовані.
z6_take_same(_Val, [], Acc, Acc, []).
z6_take_same(Val, [H|T], Acc, N, Tail) :-
    (   H =:= Val
    ->  Acc1 is Acc + 1,
        z6_take_same(Val, T, Acc1, N, Tail)
    ;   N = Acc,
        Tail = [H|T]
    ).

% z6_sum_of_squares(++Counts, --Total)
% Індикатори:
%   ++Counts - обов’язково конкретизований (список Sum-Qty)
%   --Total  - обов’язково вільна змінна (сума квадратів кількостей)
%
% Призначення:
%   1) z6_sum_of_squares(++, --): Total = Σ Qty^2.
%
% Пояснення відсутності інших змістовних призначень:
%   Counts має бути конкретизований, бо ми його розбираємо рекурсивно і рахуємо арифметику.
z6_sum_of_squares([], 0).
z6_sum_of_squares([_S-Qty|T], Total) :-
    z6_sum_of_squares(T, Rest),
    Total is Rest + Qty*Qty.

/** <examples>
?- z6_lucky_count(C).
% C = 1750.
*/


% ============================================================
% 7) Циклічний зсув елементів списку:
%    7.1. На n праворуч (останній іде в голову, якщо n=1).
%    7.2. На n ліворуч (голова іде в хвіст, якщо n=1).
% ============================================================

% z7_shift_right(++List, ++N, --Shifted)
% Індикатори:
%   ++List    - обов’язково конкретизований
%   ++N       - обов’язково конкретизований (ціле, очікуємо N>=0)
%   --Shifted - обов’язково вільна змінна
%
% Призначення:
%   1) z7_shift_right(++, ++, --): обчислити циклічний зсув праворуч.
%
% Неочевидні built-in:
%   - length/2: довжина списку.
z7_shift_right(List, N, Shifted) :-
    (   List = []
    ->  Shifted = []
    ;   length(List, Len),
        K is N mod Len,
        T is Len - K,
        z7_split_at(T, List, Left, Right),
        append(Right, Left, Shifted)
    ).

% z7_shift_left(++List, ++N, --Shifted)
% Індикатори:
%   ++List    - обов’язково конкретизований
%   ++N       - обов’язково конкретизований (ціле, очікуємо N>=0)
%   --Shifted - обов’язково вільна змінна
%
% Призначення:
%   1) z7_shift_left(++, ++, --): обчислити циклічний зсув ліворуч.
z7_shift_left(List, N, Shifted) :-
    (   List = []
    ->  Shifted = []
    ;   length(List, Len),
        K is N mod Len,
        z7_split_at(K, List, Left, Right),
        append(Right, Left, Shifted)
    ).

% z7_split_at(++K, ++List, --Front, --Back)
% Індикатори:
%   ++K     - обов’язково конкретизований (0..length(List))
%   ++List  - обов’язково конкретизований
%   --Front - обов’язково вільна змінна
%   --Back  - обов’язково вільна змінна
%
% Призначення:
%   1) z7_split_at(++, ++, --, --): розбити список на Front довжини K та Back решта.
%
% Пояснення відсутності інших змістовних призначень:
%   Через арифметику (K1 is K-1) та рекурсію K і List мають бути конкретизовані.
z7_split_at(0, List, [], List) :- !.
z7_split_at(K, [H|T], [H|Front], Back) :-
    K > 0,
    K1 is K - 1,
    z7_split_at(K1, T, Front, Back).

/** <examples>
?- z7_shift_right([a,b,c,d,e], 1, Xs).
% Xs = [e, a, b, c, d].

?- z7_shift_left([a,b,c,d,e], 2, Xs).
% Xs = [c, d, e, a, b].

?- z7_shift_right([1,2,3,4], 10, Xs).
% Xs = [3, 4, 1, 2].
*/